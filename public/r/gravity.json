{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "gravity",
  "type": "registry:ui",
  "dependencies": [
    "lodash",
    "matter-js",
    "svg-path-commander",
    "poly-decomp",
    "@types/matter-js"
  ],
  "registryDependencies": [
    "https://fancycomponents.dev/r/calculate-position.json",
    "https://fancycomponents.dev/r/svg-path-to-vertices.json"
  ],
  "files": [
    {
      "path": "/fancy/physics/gravity.tsx",
      "content": "\"use client\"\r\n\r\nimport {\r\n  createContext,\r\n  forwardRef,\r\n  ReactNode,\r\n  useCallback,\r\n  useContext,\r\n  useEffect,\r\n  useImperativeHandle,\r\n  useRef,\r\n  useState,\r\n} from \"react\"\r\nimport { calculatePosition } from \"@/utils/calculate-position\"\r\nimport { parsePathToVertices } from \"@/utils/svg-path-to-vertices\"\r\nimport { debounce } from \"lodash\"\r\nimport Matter, {\r\n  Bodies,\r\n  Common,\r\n  Engine,\r\n  Events,\r\n  Mouse,\r\n  MouseConstraint,\r\n  Query,\r\n  Render,\r\n  Runner,\r\n  World,\r\n} from \"matter-js\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\ntype GravityProps = {\r\n  children: ReactNode\r\n  debug?: boolean\r\n  gravity?: { x: number; y: number }\r\n  resetOnResize?: boolean\r\n  grabCursor?: boolean\r\n  addTopWall?: boolean\r\n  autoStart?: boolean\r\n  className?: string\r\n}\r\n\r\ntype PhysicsBody = {\r\n  element: HTMLElement\r\n  body: Matter.Body\r\n  props: MatterBodyProps\r\n}\r\n\r\ntype MatterBodyProps = {\r\n  children: ReactNode\r\n  matterBodyOptions?: Matter.IBodyDefinition\r\n  isDraggable?: boolean\r\n  bodyType?: \"rectangle\" | \"circle\" | \"svg\"\r\n  sampleLength?: number\r\n  x?: number | string\r\n  y?: number | string\r\n  angle?: number\r\n  className?: string\r\n}\r\n\r\nexport type GravityRef = {\r\n  start: () => void\r\n  stop: () => void\r\n  reset: () => void\r\n}\r\n\r\nconst GravityContext = createContext<{\r\n  registerElement: (\r\n    id: string,\r\n    element: HTMLElement,\r\n    props: MatterBodyProps\r\n  ) => void\r\n  unregisterElement: (id: string) => void\r\n} | null>(null)\r\n\r\nexport const MatterBody = ({\r\n  children,\r\n  className,\r\n  matterBodyOptions = {\r\n    friction: 0.1,\r\n    restitution: 0.1,\r\n    density: 0.001,\r\n    isStatic: false,\r\n  },\r\n  bodyType = \"rectangle\",\r\n  isDraggable = true,\r\n  sampleLength = 15,\r\n  x = 0,\r\n  y = 0,\r\n  angle = 0,\r\n  ...props\r\n}: MatterBodyProps) => {\r\n  const elementRef = useRef<HTMLDivElement>(null)\r\n  const idRef = useRef(Math.random().toString(36).substring(7))\r\n  const context = useContext(GravityContext)\r\n\r\n  useEffect(() => {\r\n    if (!elementRef.current || !context) return\r\n    context.registerElement(idRef.current, elementRef.current, {\r\n      children,\r\n      matterBodyOptions,\r\n      bodyType,\r\n      sampleLength,\r\n      isDraggable,\r\n      x,\r\n      y,\r\n      angle,\r\n      ...props,\r\n    })\r\n\r\n    return () => context.unregisterElement(idRef.current)\r\n  }, [props, children, matterBodyOptions, isDraggable])\r\n\r\n  return (\r\n    <div\r\n      ref={elementRef}\r\n      className={cn(\r\n        \"absolute\",\r\n        className,\r\n        isDraggable && \"pointer-events-none\"\r\n      )}\r\n    >\r\n      {children}\r\n    </div>\r\n  )\r\n}\r\n\r\nconst Gravity = forwardRef<GravityRef, GravityProps>(\r\n  (\r\n    {\r\n      children,\r\n      debug = false,\r\n      gravity = { x: 0, y: 1 },\r\n      grabCursor = true,\r\n      resetOnResize = true,\r\n      addTopWall = true,\r\n      autoStart = true,\r\n      className,\r\n      ...props\r\n    },\r\n    ref\r\n  ) => {\r\n    const canvas = useRef<HTMLDivElement>(null)\r\n    const engine = useRef(Engine.create())\r\n    const render = useRef<Render>()\r\n    const runner = useRef<Runner>()\r\n    const bodiesMap = useRef(new Map<string, PhysicsBody>())\r\n    const frameId = useRef<number>()\r\n    const mouseConstraint = useRef<Matter.MouseConstraint>()\r\n    const mouseDown = useRef(false)\r\n    const [canvasSize, setCanvasSize] = useState({ width: 0, height: 0 })\r\n\r\n    const isRunning = useRef(false)\r\n\r\n    // Register Matter.js body in the physics world\r\n    const registerElement = useCallback(\r\n      (id: string, element: HTMLElement, props: MatterBodyProps) => {\r\n        if (!canvas.current) return\r\n        const width = element.offsetWidth\r\n        const height = element.offsetHeight\r\n        const canvasRect = canvas.current!.getBoundingClientRect()\r\n\r\n        const angle = (props.angle || 0) * (Math.PI / 180)\r\n\r\n        const x = calculatePosition(props.x, canvasRect.width, width)\r\n        const y = calculatePosition(props.y, canvasRect.height, height)\r\n\r\n        let body\r\n        if (props.bodyType === \"circle\") {\r\n          const radius = Math.max(width, height) / 2\r\n          body = Bodies.circle(x, y, radius, {\r\n            ...props.matterBodyOptions,\r\n            angle: angle,\r\n            render: {\r\n              fillStyle: debug ? \"#888888\" : \"#00000000\",\r\n              strokeStyle: debug ? \"#333333\" : \"#00000000\",\r\n              lineWidth: debug ? 3 : 0,\r\n            },\r\n          })\r\n        } else if (props.bodyType === \"svg\") {\r\n          const paths = element.querySelectorAll(\"path\")\r\n          const vertexSets: Matter.Vector[][] = []\r\n\r\n          paths.forEach((path) => {\r\n            const d = path.getAttribute(\"d\")\r\n            const p = parsePathToVertices(d!, props.sampleLength)\r\n            vertexSets.push(p)\r\n          })\r\n\r\n          body = Bodies.fromVertices(x, y, vertexSets, {\r\n            ...props.matterBodyOptions,\r\n            angle: angle,\r\n            render: {\r\n              fillStyle: debug ? \"#888888\" : \"#00000000\",\r\n              strokeStyle: debug ? \"#333333\" : \"#00000000\",\r\n              lineWidth: debug ? 3 : 0,\r\n            },\r\n          })\r\n        } else {\r\n          body = Bodies.rectangle(x, y, width, height, {\r\n            ...props.matterBodyOptions,\r\n            angle: angle,\r\n            render: {\r\n              fillStyle: debug ? \"#888888\" : \"#00000000\",\r\n              strokeStyle: debug ? \"#333333\" : \"#00000000\",\r\n              lineWidth: debug ? 3 : 0,\r\n            },\r\n          })\r\n        }\r\n\r\n        if (body) {\r\n          World.add(engine.current.world, [body])\r\n          bodiesMap.current.set(id, { element, body, props })\r\n        }\r\n      },\r\n      [debug]\r\n    )\r\n\r\n    // Unregister Matter.js body from the physics world\r\n    const unregisterElement = useCallback((id: string) => {\r\n      const body = bodiesMap.current.get(id)\r\n      if (body) {\r\n        World.remove(engine.current.world, body.body)\r\n        bodiesMap.current.delete(id)\r\n      }\r\n    }, [])\r\n\r\n    // Keep react elements in sync with the physics world\r\n    const updateElements = useCallback(() => {\r\n      bodiesMap.current.forEach(({ element, body }) => {\r\n        const { x, y } = body.position\r\n        const rotation = body.angle * (180 / Math.PI)\r\n\r\n        element.style.transform = `translate(${\r\n          x - element.offsetWidth / 2\r\n        }px, ${y - element.offsetHeight / 2}px) rotate(${rotation}deg)`\r\n      })\r\n\r\n      frameId.current = requestAnimationFrame(updateElements)\r\n    }, [])\r\n\r\n    const initializeRenderer = useCallback(() => {\r\n      if (!canvas.current) return\r\n\r\n      const height = canvas.current.offsetHeight\r\n      const width = canvas.current.offsetWidth\r\n\r\n      Common.setDecomp(require(\"poly-decomp\"))\r\n\r\n      engine.current.gravity.x = gravity.x\r\n      engine.current.gravity.y = gravity.y\r\n\r\n      render.current = Render.create({\r\n        element: canvas.current,\r\n        engine: engine.current,\r\n        options: {\r\n          width,\r\n          height,\r\n          wireframes: false,\r\n          background: \"#00000000\",\r\n        },\r\n      })\r\n\r\n      const mouse = Mouse.create(render.current.canvas)\r\n      mouseConstraint.current = MouseConstraint.create(engine.current, {\r\n        mouse: mouse,\r\n        constraint: {\r\n          stiffness: 0.2,\r\n          render: {\r\n            visible: debug,\r\n          },\r\n        },\r\n      })\r\n\r\n      // Add walls\r\n      const walls = [\r\n        // Floor\r\n        Bodies.rectangle(width / 2, height + 10, width, 20, {\r\n          isStatic: true,\r\n          friction: 1,\r\n          render: {\r\n            visible: debug,\r\n          },\r\n        }),\r\n\r\n        // Right wall\r\n        Bodies.rectangle(width + 10, height / 2, 20, height, {\r\n          isStatic: true,\r\n          friction: 1,\r\n          render: {\r\n            visible: debug,\r\n          },\r\n        }),\r\n\r\n        // Left wall\r\n        Bodies.rectangle(-10, height / 2, 20, height, {\r\n          isStatic: true,\r\n          friction: 1,\r\n          render: {\r\n            visible: debug,\r\n          },\r\n        }),\r\n      ]\r\n\r\n      const topWall = addTopWall\r\n        ? Bodies.rectangle(width / 2, -10, width, 20, {\r\n            isStatic: true,\r\n            friction: 1,\r\n            render: {\r\n              visible: debug,\r\n            },\r\n          })\r\n        : null\r\n\r\n      if (topWall) {\r\n        walls.push(topWall)\r\n      }\r\n\r\n      const touchingMouse = () =>\r\n        Query.point(\r\n          engine.current.world.bodies,\r\n          mouseConstraint.current?.mouse.position || { x: 0, y: 0 }\r\n        ).length > 0\r\n\r\n      if (grabCursor) {\r\n        Events.on(engine.current, \"beforeUpdate\", (event) => {\r\n          if (canvas.current) {\r\n            if (!mouseDown.current && !touchingMouse()) {\r\n              canvas.current.style.cursor = \"default\"\r\n            } else if (touchingMouse()) {\r\n              canvas.current.style.cursor = mouseDown.current\r\n                ? \"grabbing\"\r\n                : \"grab\"\r\n            }\r\n          }\r\n        })\r\n\r\n        canvas.current.addEventListener(\"mousedown\", (event) => {\r\n          mouseDown.current = true\r\n\r\n          if (canvas.current) {\r\n            if (touchingMouse()) {\r\n              canvas.current.style.cursor = \"grabbing\"\r\n            } else {\r\n              canvas.current.style.cursor = \"default\"\r\n            }\r\n          }\r\n        })\r\n        canvas.current.addEventListener(\"mouseup\", (event) => {\r\n          mouseDown.current = false\r\n\r\n          if (canvas.current) {\r\n            if (touchingMouse()) {\r\n              canvas.current.style.cursor = \"grab\"\r\n            } else {\r\n              canvas.current.style.cursor = \"default\"\r\n            }\r\n          }\r\n        })\r\n      }\r\n\r\n      World.add(engine.current.world, [mouseConstraint.current, ...walls])\r\n\r\n      render.current.mouse = mouse\r\n\r\n      runner.current = Runner.create()\r\n      Render.run(render.current)\r\n      updateElements()\r\n      runner.current.enabled = false\r\n\r\n      if (autoStart) {\r\n        runner.current.enabled = true\r\n        startEngine()\r\n      }\r\n    }, [updateElements, debug, autoStart])\r\n\r\n    // Clear the Matter.js world\r\n    const clearRenderer = useCallback(() => {\r\n      if (frameId.current) {\r\n        cancelAnimationFrame(frameId.current)\r\n      }\r\n\r\n      if (mouseConstraint.current) {\r\n        World.remove(engine.current.world, mouseConstraint.current)\r\n      }\r\n\r\n      if (render.current) {\r\n        Mouse.clearSourceEvents(render.current.mouse)\r\n        Render.stop(render.current)\r\n        render.current.canvas.remove()\r\n      }\r\n\r\n      if (runner.current) {\r\n        Runner.stop(runner.current)\r\n      }\r\n\r\n      if (engine.current) {\r\n        World.clear(engine.current.world, false)\r\n        Engine.clear(engine.current)\r\n      }\r\n\r\n      bodiesMap.current.clear()\r\n    }, [])\r\n\r\n    const handleResize = useCallback(() => {\r\n      if (!canvas.current || !resetOnResize) return\r\n\r\n      const newWidth = canvas.current.offsetWidth\r\n      const newHeight = canvas.current.offsetHeight\r\n\r\n      setCanvasSize({ width: newWidth, height: newHeight })\r\n\r\n      // Clear and reinitialize\r\n      clearRenderer()\r\n      initializeRenderer()\r\n    }, [clearRenderer, initializeRenderer, resetOnResize])\r\n\r\n    const startEngine = useCallback(() => {\r\n      if (runner.current) {\r\n        runner.current.enabled = true\r\n\r\n        Runner.run(runner.current, engine.current)\r\n      }\r\n      if (render.current) {\r\n        Render.run(render.current)\r\n      }\r\n      frameId.current = requestAnimationFrame(updateElements)\r\n      isRunning.current = true\r\n    }, [updateElements, canvasSize])\r\n\r\n    const stopEngine = useCallback(() => {\r\n      if (!isRunning.current) return\r\n\r\n      if (runner.current) {\r\n        Runner.stop(runner.current)\r\n      }\r\n      if (render.current) {\r\n        Render.stop(render.current)\r\n      }\r\n      if (frameId.current) {\r\n        cancelAnimationFrame(frameId.current)\r\n      }\r\n      isRunning.current = false\r\n    }, [])\r\n\r\n    const reset = useCallback(() => {\r\n      stopEngine()\r\n      bodiesMap.current.forEach(({ element, body, props }) => {\r\n        body.angle = props.angle || 0\r\n\r\n        const x = calculatePosition(\r\n          props.x,\r\n          canvasSize.width,\r\n          element.offsetWidth\r\n        )\r\n        const y = calculatePosition(\r\n          props.y,\r\n          canvasSize.height,\r\n          element.offsetHeight\r\n        )\r\n        body.position.x = x\r\n        body.position.y = y\r\n      })\r\n      updateElements()\r\n      handleResize()\r\n    }, [])\r\n\r\n    useImperativeHandle(\r\n      ref,\r\n      () => ({\r\n        start: startEngine,\r\n        stop: stopEngine,\r\n        reset,\r\n      }),\r\n      [startEngine, stopEngine]\r\n    )\r\n\r\n    useEffect(() => {\r\n      if (!resetOnResize) return\r\n\r\n      const debouncedResize = debounce(handleResize, 500)\r\n      window.addEventListener(\"resize\", debouncedResize)\r\n\r\n      return () => {\r\n        window.removeEventListener(\"resize\", debouncedResize)\r\n        debouncedResize.cancel()\r\n      }\r\n    }, [handleResize, resetOnResize])\r\n\r\n    useEffect(() => {\r\n      initializeRenderer()\r\n      return clearRenderer\r\n    }, [initializeRenderer, clearRenderer])\r\n\r\n    return (\r\n      <GravityContext.Provider value={{ registerElement, unregisterElement }}>\r\n        <div\r\n          ref={canvas}\r\n          className={cn(className, \"absolute top-0 left-0 w-full h-full\")}\r\n          {...props}\r\n        >\r\n          {children}\r\n        </div>\r\n      </GravityContext.Provider>\r\n    )\r\n  }\r\n)\r\n\r\nGravity.displayName = \"Gravity\"\r\nexport default Gravity\r\n",
      "type": "registry:ui",
      "target": "/fancy/components/physics/gravity.tsx"
    },
    {
      "path": "/utils/calculate-position.ts",
      "content": "export function calculatePosition(\r\n  value: number | string | undefined,\r\n  containerSize: number,\r\n  elementSize: number\r\n): number {\r\n  // Handle percentage strings (e.g. \"50%\")\r\n  if (typeof value === \"string\" && value.endsWith(\"%\")) {\r\n    const percentage = parseFloat(value) / 100\r\n    return containerSize * percentage\r\n  }\r\n\r\n  // Handle direct pixel values\r\n  if (typeof value === \"number\") {\r\n    return value\r\n  }\r\n\r\n  // If no value provided, center the element\r\n  return (containerSize - elementSize) / 2\r\n}\r\n",
      "type": "registry:lib",
      "target": "/utils/calculate-position.ts"
    },
    {
      "path": "/utils/svg-path-to-vertices.ts",
      "content": "import SVGPathCommander from \"svg-path-commander\"\r\n\r\n// Function to convert SVG path `d` to vertices\r\nexport function parsePathToVertices(path: string, sampleLength = 15) {\r\n  // Convert path to absolute commands\r\n  const commander = new SVGPathCommander(path)\r\n\r\n  const points: { x: number; y: number }[] = []\r\n  let lastPoint: { x: number; y: number } | null = null\r\n\r\n  // Get total length of the path\r\n  const totalLength = commander.getTotalLength()\r\n  let length = 0\r\n\r\n  // Sample points along the path\r\n  while (length < totalLength) {\r\n    const point = commander.getPointAtLength(length)\r\n\r\n    // Only add point if it's different from the last one\r\n    if (!lastPoint || point.x !== lastPoint.x || point.y !== lastPoint.y) {\r\n      points.push({ x: point.x, y: point.y })\r\n      lastPoint = point\r\n    }\r\n\r\n    length += sampleLength\r\n  }\r\n\r\n  // Ensure we get the last point\r\n  const finalPoint = commander.getPointAtLength(totalLength)\r\n  if (\r\n    lastPoint &&\r\n    (finalPoint.x !== lastPoint.x || finalPoint.y !== lastPoint.y)\r\n  ) {\r\n    points.push({ x: finalPoint.x, y: finalPoint.y })\r\n  }\r\n\r\n  return points\r\n}",
      "type": "registry:lib",
      "target": "/utils/svg-path-to-vertices.ts"
    }
  ]
}