---
title: Letter 3D Swap
description: A text component that swap the letters in a text with a box 3D effect.
component: true
---

<ComponentPreview name='letter-3d-swap-demo' />

## Installation

<Tabs defaultValue="cli">

<TabsList>
  <TabsTrigger value="cli">CLI</TabsTrigger>
  <TabsTrigger value="manual">Manual</TabsTrigger>
</TabsList>
<TabsContent value="cli">

```bash
npx shadcn@latest add "https://fancycomponents.dev/r/letter-3d-swap.json"
```

</TabsContent>
<TabsContent value="manual">

<ComponentSource name="letter-3d-swap" />

</TabsContent>
</Tabs>

## Usage

Just wrap your text with the component and set the `rotateDirection` prop to the direction you want the text to rotate, the rest will be taken care by the component.

## Understanding the component

### Splitting the text into characters

First, we split the text into `WorldObject` objects, each containing an array of characters and a boolean indicating whether there should be a space after the character. We use a handy function for this, we should respect emojis too.
```tsx
// handy function to split text into characters with support for unicode and emojis
const splitIntoCharacters = (text: string): string[] => {
  if (typeof Intl !== "undefined" && "Segmenter" in Intl) {
    const segmenter = new Intl.Segmenter("en", { granularity: "grapheme" })
    return Array.from(segmenter.segment(text), ({ segment }) => segment)
  }
  // Fallback for browsers that don't support Intl.Segmenter
  return Array.from(text)
}
```

This method also helps us to ensure that words stay together and properly spaced when the text wraps across multiple lines. Without this approach, simply splitting by characters would break words at line boundaries.

```tsx
// Splitting the text into animation segments
const characters = useMemo(() => {
    const t = text.split(" ")
    const result = t.map((word: string, i: number) => ({
      characters: splitIntoCharacters(word),
      needsSpace: i !== t.length - 1,
    }))
    return result
}, [text])
```

### 3D Transforms

When rendering each character, we create two instances of it - a front face and a second face. The second face is absolutely positioned relative to the first one and uses 3D CSS transforms to create the illusion that it's on a different face of a 3D box. Which face it appears on depends on the `rotateDirection` prop:

- `"top"` - Character appears to flip upward from the top face
- `"right"` - Character appears to flip from the right side 
- `"bottom"` - Character appears to flip downward from the bottom face
- `"left"` - Character appears to flip from the left side

For the top and bottom rotations, we first rotate the second face on the X axis:
   - For top: `rotateX(-90deg)` to flip upward
   - For bottom: `rotateX(90deg)` to flip downward

Then offset it by half the height of the first face using the `lh` CSS unit (which represents one line height). This `0.5lh` offset will position it exactly at the edge of our virtual 3D box.

For left/right rotations, we use a bit more complex series of transforms to place the face on the side. This is needed because character widths are different in most fonts (except monospace fonts where all characters are the same width). We can still use percentage-based translations, at least on the X and Y axes (not on Z though). For the left rotation, this is what we use:

```tsx
"rotateY(90deg) translateX(50%) rotateY(-90deg) translateX(50%) rotateY(-90deg) translateX(50%)"
```

Instead of an explanation, check out this demo which does the transform step by step:

<ComponentPreview name='letter-3d-swap-explanation-demo' />

Of course, you can achieve the same result by applying (other) transforms in a different order, but this sequence works well for our needs.

### Animation

Now that we have our virtual 3D box, the only thing left is to rotate each charater box. For this, we use the `useAnimate` hook from [motion](https://motion.dev/docs/use-animate). This gives us a scope and an `animate` function to control the animation. We add `.,letter-3d-swap-char-box-item` class name to each char box, so we can select and animate them with the `animate` function. All the animation is completed, we just reset the transform to the original state.

```tsx
// Animate each character with its specific delay
await animate(
  ".letter-3d-swap-char-box-item",
  { transform: rotationTransform },
  {
    ...transition,
    delay: (i: number) => delays[i],
  }

// Reset all boxes
await animate(
  ".letter-3d-swap-char-box-item",
  { transform: "rotateX(0deg) rotateY(0deg)" },
  { duration: 0 }
)
```

The transform is just a 90/-90 degree rotation either on the X or Y axis, depending on the `rotateDirection` prop.

### Stagger

The delay is calculated based on the `staggerFrom` prop, which can be set to `first`, `last`, `center`, `random` or a number. If it's a number, it's used as the index of the character to stagger from. For example, if `staggerFrom` is set to `2`, the second character will be staggered from the third one. We have a handy function to calculate the correct delay for each character:

```tsx
// Helper function to calculate stagger delay for each text segment
const getStaggerDelay = useCallback(
  (index: number, totalChars: number) => {
    const total = totalChars
    if (staggerFrom === "first") return index * staggerDuration
    if (staggerFrom === "last") return (total - 1 - index) * staggerDuration
    if (staggerFrom === "center") {
      const center = Math.floor(total / 2)
      return Math.abs(center - index) * staggerDuration
    }
    if (staggerFrom === "random") {
      const randomIndex = Math.floor(Math.random() * total)
      return Math.abs(randomIndex - index) * staggerDuration
    }
    return Math.abs(staggerFrom - index) * staggerDuration
  },
  [staggerFrom, staggerDuration]
)
```

Check out the demo to see the possible values for `staggerFrom`.

<ComponentPreview name='letter-3d-swap-stagger-demo' />

## Props

### Letter3DSwapProps

<Table>
  <TableHeader>
    <TableRow>
      <TableHead>Prop</TableHead>
      <TableHead>Type</TableHead>
      <TableHead>Default</TableHead>
      <TableHead>Description</TableHead>
    </TableRow>
  </TableHeader>
  <TableBody>
    <TableRow>
      <TableCell>children<span className="text-red-500">*</span></TableCell>
      <TableCell>`React.ReactNode`</TableCell>
      <TableCell>-</TableCell>
      <TableCell>The content to be displayed and animated</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>as</TableCell>
      <TableCell>`ElementType`</TableCell>
      <TableCell>`p`</TableCell>
      <TableCell>HTML Tag to render the component as</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>mainClassName</TableCell>
      <TableCell>`string`</TableCell>
      <TableCell>-</TableCell>
      <TableCell>Class name for the main container element</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>frontFaceClassName</TableCell>
      <TableCell>`string`</TableCell>
      <TableCell>-</TableCell>
      <TableCell>Class name for the front face element</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>secondFaceClassName</TableCell>
      <TableCell>`string`</TableCell>
      <TableCell>-</TableCell>
      <TableCell>Class name for the secondary face element</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>staggerDuration</TableCell>
      <TableCell>`number`</TableCell>
      <TableCell>`0.05`</TableCell>
      <TableCell>Duration of stagger delay between elements in seconds</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>staggerFrom</TableCell>
      <TableCell>`"first" | "last" | "center" | "random" | number`</TableCell>
      <TableCell>`"first"`</TableCell>
      <TableCell>Direction to stagger animations from</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>transition</TableCell>
      <TableCell>`ValueAnimationTransition | AnimationOptions`</TableCell>
      <TableCell>`{ type: "spring", damping: 25, stiffness: 300 }`</TableCell>
      <TableCell>Animation transition configuration</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>rotateDirection</TableCell>
      <TableCell>`"top" | "right" | "bottom" | "left"`</TableCell>
      <TableCell>`"right"`</TableCell>
      <TableCell>Direction of rotation</TableCell>
    </TableRow>
  </TableBody>
</Table>
