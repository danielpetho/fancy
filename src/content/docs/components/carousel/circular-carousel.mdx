---
title: Circular Carousel
description: A circular carousel component that displays items in a rotating circle layout with drag support and smooth animations.
component: true
---

<ComponentPreview name="circular-carousel-demo-2" framerLink="https://framer.university/resources/circular-selection-on-scroll-in-framer" />

## Installation

<Tabs defaultValue="cli">

<TabsList>
  <TabsTrigger value="cli">CLI</TabsTrigger>
  <TabsTrigger value="manual">Manual</TabsTrigger>
</TabsList>
<TabsContent value="cli">

<InstallTabs
  command='shadcn@latest add "https://fancycomponents.dev/r/circular-carousel.json"'
  npx
/>

</TabsContent>
<TabsContent value="manual">

<ComponentSource name="circular-carousel" />

</TabsContent>
</Tabs>

## Usage

Create your own items and pass them to the `items` prop, the rest of the props are optional. You can either define a radius in pixels, or set it to `auto` (default) to automatically fill up the parent container.

<CodeSnippet title="High-level example">
  ```tsx
  const items = Array.from({ length: 10 }, (_, index) => (
    <img src={`https://picsum.photos/200/300?random=${index}`} alt={`Item #${index + 1}`} />
  ))

  <CircularCarousel items={items} radius={300} />
  ```
</CodeSnippet>

## Understanding the Component

The component is really similar to a regular one-dimensional carousel, only the items here are positioned in a circle, and rotated around the center of the container. The items are evenly distributed along the circle path. Therefore, taking care of responsiveness, and avoiding overlapping elements (if that's what you want) is your responsibility.

<CodeSnippet title="Distribution in a circle">
```tsx
  //...

  // Angle difference between each item in radians
  const angleStep = (2 * Math.PI) / items.length

  //...

  {items.map((item, index) => {
    const baseAngle = index * angleStep
    const angle = baseAngle + totalRotation

    let itemTransition = transition

    //...

    return (
      <motion.div
        key={index}
        className={cn(
          "absolute ",
          enableDrag && grabCursor && "cursor-grab"
        )}
        animate={{
          transform: keepOriginalOrientation
            ? `rotate(${angle}rad) translate(0, -${calculatedRadius}px) rotate(${-angle}rad)`
            : `rotate(${angle}rad) translate(0, -${calculatedRadius}px)`,
          zIndex:
            currentIndex === index && focusedOnTop
              ? baseZIndex + items.length
              : baseZIndex + index,
        }}
        initial={false}

        //...
        >
        {/*... */}
      </motion.div>
```
</CodeSnippet>

The `calculatedRadius` in the transform is either the `radius` passed down, or if set to `auto`, it will be the minimum of the container's width and height, divided by 2.

### Staggering animations

The circular carousel supports staggered animations, 

We apply rotation and animation to each item individually, rather than rotating the entire carousel as a single unit. This per-item approach allows us to apply an animation for each item individually. This also makes it possible to support staggered animations, where each item animates with a slight delay based on its position relative to a fixed origin point.

You can control this behavior with two props:
- `staggerDelay`: The delay (in seconds) between each item's animation
- `staggerOrigin`: The fixed angle (in radians) where the stagger effect starts from

<CodeSnippet title="Stagger delay calculation">
```tsx
//,,,
{items.map((item, index) => {
  const baseAngle = index * angleStep
  const angle = baseAngle + totalRotation

  let itemTransition = transition
  if (prefersReducedMotion || isTabNavigation) {
    itemTransition = { duration: 0 }
  } else if (staggerDelay > 0) {
    const itemCurrentAngle = angle

    let clockwiseDistance = itemCurrentAngle - staggerOrigin

    while (clockwiseDistance < 0) clockwiseDistance += 2 * Math.PI
    while (clockwiseDistance >= 2 * Math.PI)
      clockwiseDistance -= 2 * Math.PI

    const stepCount =
      Math.round((clockwiseDistance / (2 * Math.PI)) * items.length) %
      items.length

    itemTransition = {
      ...transition,
      delay: (transition.delay || 0) + stepCount * staggerDelay,
    }
  }
//,,,
```
</CodeSnippet>

- `staggerOrigin` sets where the stagger effect starts (in radians).
- For each item, calculate how far it is from this origin around the circle.
- Convert that distance into a step number.
- Each item's animation is delayed by `stepCount * staggerDelay`.

This produces a wave-like effect as the animation propagates around the circle:

<ComponentPreview name="circular-carousel-continuous-focus-demo" />

### Continuous Focus Mapping

The circular carousel supports continuous focus mapping during dragging, which allows items to smoothly transition their focus effects based on their position relative to a focus origin point.

When `continuousFocus` is enabled, items will continuously interpolate properties defined in `focusStyleInterpolation` based on their angular distance from the `focusOrigin`. You can control the range of the focus effect using `focusItemRange`.

<CodeSnippet title="Continuous Focus Example">
```tsx
<CircularCarousel
  items={items}
  radius={200}
  continuousFocus={true}
  focusOrigin={0} // Focus at the top of the circle (0 radians)
  focusItemRange={3} // Affect 3 items on each side of focus origin
  focusStyleInterpolation={[
    {
      property: "scale",
      from: 1,
      to: 1.5,
    },
    {
      property: "rotateZ",
      from: 0,
      to: 15,
    },
    {
      property: "translateY",
      from: 0,
      to: -100,
    },
    {
      property: "borderWidth",
      from: 0,
      to: 10,
    },
  ]}
  enableDrag={true}
/>
```
</CodeSnippet>

Key features of continuous focus:
- **Configurable range**: Use `focusItemRange` to control how many items are affected (1 = adjacent only, higher values = wider range)
- **Full circle support**: If `focusItemRange >= items.length/2`, the entire circle is affected with smooth falloff
- **Smooth transitions**: Focus effects are applied continuously during dragging, not just when items snap to positions
- **Distance-based intensity**: Items closer to the focus origin have stronger effects
- **Configurable origin**: Set the `focusOrigin` angle to define where the strongest focus should be
- **Unified interpolation**: Use `focusStyleInterpolation` to animate both CSS variables and motion properties with from/to ranges


